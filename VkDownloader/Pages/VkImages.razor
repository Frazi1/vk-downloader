@page "/vk_images"
@using VkDownloader.Vk
@using System.Threading
@using VkDownloader.Vk.Wall
@* ReSharper disable once RedundantUsingDirective *@
@using Sve.Blazor.InfiniteScroll.Components;

@attribute [Authorize]
@inject VkImagesService ImagesService;
@inject WallStateStorage WallStateStorage;

<div class="px-4 flex-column position-sticky bg-light" style="top: 0">
    <input placeholder="VK group link" @bind="WallState.GroupName">
    <input placeholder="Offset" @bind="WallState.Offset">
    <div class="btn-group" role="group">
        <button class="btn btn-primary" @onclick="async () => await FetchNextImages(false)">Find</button>
        @if (LoadRequested)
        {
            <button class="btn btn-primary " @onclick="ClearImages">Clear</button>
        }    
    </div>
</div>

<div>
    Recommended groups:
    <ul>
        @foreach ((string name, string link) in RecommendedLinks)
        {
            <li @onclick="async () => await ChangeGroup(link)">@name</li>
        }
    </ul>
</div>

<div>
    <InfiniteScroll ObserverTargetId="scroll-end" ObservableTargetReached="async e => await FetchNextImages(true)">
        <ul style="list-style-type: none">
            @foreach (string link in FetchedLinks)
            {
                <li>
                    <img src="@link"/>
                </li>
            }
            <li id="scroll-end"></li>
        </ul>
    </InfiniteScroll>

</div>

@code {

    private static readonly Dictionary<string, string> RecommendedLinks = new()
    {
        {"Кхе-кхе", "khe_kkhe"},
        {"Котизм", "catism"}
    };
    
    private readonly SemaphoreSlim _semaphore = new(1);
    private Task _lastUpdate;


    private WallState WallState { get; set; } = new(string.Empty, 0);
    private int LoadedCount { get; set; }
    private bool LoadRequested { get; set; }
    private List<string> FetchedLinks { get; set; } = new();
    

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            WallState = await WallStateStorage.GetLastViewedWall() ?? WallState;
            StateHasChanged();
        }
    }

    private async Task FetchNextImages(bool infiniteScroll)
    {
        const int countPerLoad = 10;
        if (_lastUpdate?.IsCompleted == false) return;
        if (infiniteScroll && !LoadRequested) return;
        try
        {
            var entered = await _semaphore.WaitAsync(0);
            if (!entered) return;
            LoadRequested = true;

            var fetchedLinks = await ImagesService.GetImagesAsync(new UserOrGroupName(WallState.GroupName), countPerLoad, WallState.Offset);
            LoadedCount += countPerLoad;
            WallState.Offset += countPerLoad;

            FetchedLinks.AddRange(fetchedLinks);

            await WallStateStorage.SaveLastViewedWall(WallState);
            _lastUpdate = Task.Delay(TimeSpan.FromSeconds(1));
        }
        finally
        {
            _semaphore.Release();
        }
    }

    private void ClearImages()
    {
        LoadRequested = false;
        FetchedLinks = new List<string>();
    }

    private async Task ChangeGroup(string groupName)
    {
        ClearImages();
        WallState.Offset = 0;
        WallState.GroupName = groupName;
        await FetchNextImages(false);
    }
    

}