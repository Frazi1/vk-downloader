@page "/vk_images"
@using VkDownloader.Vk
@using System.Threading
@using Microsoft.Extensions.Logging
@using VkDownloader.Vk.Wall
@* ReSharper disable once RedundantUsingDirective *@
@using Sve.Blazor.InfiniteScroll.Components;

@attribute [Authorize]

@inject VkImagesService ImagesService;
@inject WallStateStorage WallStateStorage;
@inject IToastService Toaster;
@inject ILogger<VkImages> Logger;

<div class="px-4 flex-column position-sticky bg-light" style="top: 0">
    <input placeholder="VK group link" @bind="WallState.GroupName">
    <input placeholder="Offset" @bind="WallState.Offset">
    <div class="btn-group" role="group">
        <button class="btn btn-primary" @onclick="() => UnderLock(() => FetchNextImages(false))">Find</button>
        @if (LoadRequested)
        {
            <button class="btn btn-primary " @onclick="ClearImages">Clear</button>
        }
    </div>
</div>

<div>
    Recommended groups:
    <ul>
        @foreach ((string name, string link) in RecommendedLinks)
        {
            <li @onclick="async () => await UnderLock(() => ChangeGroup(link))">@name</li>
        }
    </ul>
</div>

<div>
    <InfiniteScroll ObserverTargetId="scroll-end" ObservableTargetReached="async e => await UnderLock(async ()=> await FetchNextImages(true))">
        <ul style="list-style-type: none">
            @foreach (string link in FetchedLinks)
            {
                <li>
                    <img src="@link"/>
                </li>
            }
            <li id="scroll-end"></li>
        </ul>
    </InfiniteScroll>

</div>

@code {

    private static readonly Dictionary<string, string> RecommendedLinks = new()
    {
        {"Кхе-кхе", "khe_kkhe"},
        {"Котизм", "catism"}
    };

    private readonly SemaphoreSlim _semaphore = new(1);
    private CancellationTokenSource _fetchCts = new();
    private Task _lastUpdate;


    private WallState WallState { get; set; } = new(string.Empty, 0);
    private int LoadedCount { get; set; }
    private bool LoadRequested { get; set; }
    private List<string> FetchedLinks { get; set; } = new();


    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            WallState = await WallStateStorage.GetLastViewedWall() ?? WallState;
            StateHasChanged();
        }
    }

    private async Task UnderLock(Func<Task> action, TimeSpan? timeout = null)
    {
        bool entered = await _semaphore.WaitAsync(timeout.GetValueOrDefault());
        if(!entered) return;
        try
        {
            await action();
        }
        finally
        {
            _semaphore.Release();
        }
    }

    private async Task FetchNextImages(bool infiniteScroll)
    {
        
        const int countPerLoad = 10;
        
        if (_lastUpdate?.IsCompleted == false) return;

        if (infiniteScroll && !LoadRequested) return;
        try
        {
            LoadRequested = true;

            var fetchedLinks = await ImagesService.GetImagesAsync(new UserOrGroupName(WallState.GroupName), countPerLoad, WallState.Offset, _fetchCts.Token);
            LoadedCount += countPerLoad;
            WallState.Offset += countPerLoad;

            FetchedLinks.AddRange(fetchedLinks);

            await WallStateStorage.SaveLastViewedWall(WallState);
            _lastUpdate = Task.Delay(TimeSpan.FromMilliseconds(300));
        }
        // catch (TaskCanceledException)
        // {
        
        // }
        catch (Exception e)
        {
            Logger.LogError(e,"Unexpected error");
            Toaster.ShowError($"Unexpected error:{e.Message}");
        }
        finally
        {
            _semaphore.Release();
        }
    }

    private void ClearImages()
    {
        LoadRequested = false;
        FetchedLinks = new List<string>();
    }

    private async Task ChangeGroup(string groupName)
    {
        ClearImages();
        _fetchCts.Cancel();
        WallState.Offset = 0;
        WallState.GroupName = groupName;

        _fetchCts = new CancellationTokenSource();
        await FetchNextImages(false);
    }

}